//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18444
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using UnityEngine;
using UnityEditor;
using System;
using System.Linq;
using System.Reflection;
using System.Collections.Generic;

public static class CustomEditorTools
{
	#region Indent
	/// <summary>
	/// Indents by a specified amount
	/// </summary>
	/// <param name="indentAmount">Indent amount.</param>
	public static void StartIndent(float indentAmount) {
		GUILayout.BeginHorizontal();
		GUILayout.Space(indentAmount);
	}
	/// <summary>
	/// Indents by a specified amount and sets the labelWidth
	/// </summary>
	/// <param name="indentAmount">Indent amount.</param>
	/// <param name="labelWidth">Label width.</param>
	public static void StartIndent(float indentAmount, float labelWidth) {
		StartIndent(indentAmount);
		EditorGUIUtility.labelWidth = labelWidth;
	}
	
	public static void EndIndent() {
		GUILayout.EndHorizontal();
	}
	public static void EndIndent(float labelWidth) {
		EditorGUIUtility.labelWidth = labelWidth;
		GUILayout.EndHorizontal();
	}
	#endregion

	#region Draw Property
	public static void DrawProperty(this SerializedObject sO, string title, string property, params GUILayoutOption[] options)
	{
		sO.DrawProperty(title, property, true, options);
	}
	public static void DrawProperty(this SerializedObject sO, string title, string property, bool editable, params GUILayoutOption[] options)
	{
		SerializedProperty sp = sO.FindProperty(property);
		if(sp != null)
			sp.DrawProperty(title, editable, options);
	}

	public static void DrawRelativeProperty(this SerializedObject sO, string title, string baseProperty, string relativeProperty, params GUILayoutOption[] options) {
		sO.DrawRelativeProperty(title, baseProperty, relativeProperty, true, options);
	}
	public static void DrawRelativeProperty(this SerializedObject sO, string title, string baseProperty, string relativeProperty, bool editable, params GUILayoutOption[] options) {
		SerializedProperty sp = sO.FindProperty(baseProperty);
		if (sp != null)
			sp = sp.FindPropertyRelative(relativeProperty);
		if(sp != null)
			sp.DrawProperty(title, editable, options);
	}

	public static void DrawRelativeProperty(this SerializedProperty sP, string title, string relativeProperty, params GUILayoutOption[] options)
	{
		sP.DrawRelativeProperty(title, relativeProperty, true, options);
	}
	public static void DrawRelativeProperty(this SerializedProperty sP, string title, string relativeProperty, bool editable, params GUILayoutOption[] options)
	{
		SerializedProperty rP = sP.FindPropertyRelative(relativeProperty);
		if(rP != null)
			rP.DrawProperty(title, editable, options);
	}

	public static void DrawProperty(this SerializedProperty sP, string title, params GUILayoutOption[] options)
	{
		sP.DrawProperty(title, true, options);
	}
	public static void DrawProperty(this SerializedProperty sP, string title, bool editable, params GUILayoutOption[] options)
	{
		bool reEnableGUI = GUI.enabled;
		if(!editable) GUI.enabled = false;
		
		if (sP != null)
		{
			EditorGUILayout.BeginHorizontal();
			
			if (!string.IsNullOrEmpty(title)) EditorGUILayout.PropertyField(sP, new GUIContent(title), options);
			else EditorGUILayout.PropertyField(sP, options);
			
			if (!minimalisticLook)
				GUILayout.Space(18f);
			EditorGUILayout.EndHorizontal();
		}
		
		GUI.enabled = reEnableGUI;
	}
	#endregion
	
	#region Draw Header
	/// <summary>
	/// Draw a distinctly different looking header label
	/// </summary>
	
	static public bool DrawMinimalisticHeader (string text) { return DrawHeader(text, text, false, true); }
	
	/// <summary>
	/// Draw a distinctly different looking header label
	/// </summary>
	
	static public bool DrawHeader (string text) { return DrawHeader(text, text, false, minimalisticLook); }
	
	/// <summary>
	/// Draw a distinctly different looking header label
	/// </summary>
	
	static public bool DrawHeader (string text, string key) { return DrawHeader(text, key, false, minimalisticLook); }
	
	/// <summary>
	/// Draw a distinctly different looking header label
	/// </summary>
	
	static public bool DrawHeader (string text, bool detailed) { return DrawHeader(text, text, detailed, !detailed); }
	
	/// <summary>
	/// Draw a distinctly different looking header label
	/// </summary>
	
	static public bool DrawHeader (string text, string key, bool forceOn, bool minimalistic)
	{
		bool state = EditorPrefs.GetBool(key, true);
		
		if (!minimalistic) GUILayout.Space(3f);
		if (!forceOn && !state) GUI.backgroundColor = new Color(0.8f, 0.8f, 0.8f);
		GUILayout.BeginHorizontal();
		GUI.changed = false;
		
		if (minimalistic)
		{
			if (state) text = "\u25BC" + (char)0x200a + text;
			else text = "\u25BA" + (char)0x200a + text;
			
			GUILayout.BeginHorizontal();
			GUI.contentColor = EditorGUIUtility.isProSkin ? new Color(1f, 1f, 1f, 0.7f) : new Color(0f, 0f, 0f, 0.7f);
			if (!GUILayout.Toggle(true, text, "PreToolbar2", GUILayout.MinWidth(20f))) state = !state;
			GUI.contentColor = Color.white;
			GUILayout.EndHorizontal();
		}
		else
		{
			text = "<b><size=11>" + text + "</size></b>";
			if (state) text = "\u25BC " + text;
			else text = "\u25BA " + text;
			if (!GUILayout.Toggle(true, text, "dragtab", GUILayout.MinWidth(20f))) state = !state;
		}
		
		if (GUI.changed) EditorPrefs.SetBool(key, state);
		
		if (!minimalistic) GUILayout.Space(2f);
		GUILayout.EndHorizontal();
		GUI.backgroundColor = Color.white;
		if (!forceOn && !state) GUILayout.Space(3f);
		return state;
	}
	#endregion

	#region Contents
	/// <summary>
	/// Begin drawing the content area.
	/// </summary>
	
	static public void BeginContents () { BeginContents(minimalisticLook); }
	
	static bool mEndHorizontal = false;
	
	/// <summary>
	/// Begin drawing the content area.
	/// </summary>
	
	static public void BeginContents (bool minimalistic)
	{
		if (!minimalistic)
		{
			mEndHorizontal = true;
			GUILayout.BeginHorizontal();
			EditorGUILayout.BeginHorizontal("TextArea", GUILayout.MinHeight(10f));
		}
		else
		{
			mEndHorizontal = false;
			EditorGUILayout.BeginHorizontal(GUILayout.MinHeight(10f));
			GUILayout.Space(10f);
		}
		GUILayout.BeginVertical();
		GUILayout.Space(2f);
	}
	
	/// <summary>
	/// End drawing the content area.
	/// </summary>
	
	static public void EndContents ()
	{
		GUILayout.Space(3f);
		GUILayout.EndVertical();
		EditorGUILayout.EndHorizontal();
		
		if (mEndHorizontal)
		{
			GUILayout.Space(3f);
			GUILayout.EndHorizontal();
		}
		
		GUILayout.Space(3f);
	}
	#endregion

	#region Draw Array
	private class ArrayRef
	{
		private int _swap1 = -1, _swap2 = -1;
		public int swap1
		{
			get{ return _swap1;}
			set{ if(_swap1 != -1 && _swap1 != _lastSwap2) _lastSwap1 = _swap1;
					_swap1 = value;
			}
		}
		public int swap2
		{
			get{ return _swap2;}
			set{ if(_swap2 != -1) _lastSwap2 = _swap2;
				_swap2 = value;
			}
		}

		private int _lastSwap1 = -1, _lastSwap2 = -1;
		public int lastSwap1
		{
			get{return _lastSwap1;}
		}
		public int lastSwap2
		{
			get{return _lastSwap2;}
		}

		public void ResetLastSwaps()
		{
			_lastSwap1 = -1;
			_lastSwap2 = -1;
		}

		private int _index = 0;
		private int _maxIndex = 0;

		public int maxIndex
		{
			set{_maxIndex = Mathf.Max(value, 0);}
		}

		public int index
		{
			get{return _index;}
			set{_index = Mathf.Clamp(value, 0, _maxIndex);}
		}
	}

	private static Dictionary<SerializedObject, Dictionary<string, ArrayRef>> arrayRef = new Dictionary<SerializedObject, Dictionary<string, ArrayRef>>();
	private static int _depth = -1;
	private static List<string> _depthTitle = new List<string>();
	private static string _fullTitle = "";
	private static List<int> _arrayIndex = new List<int>();
	private static SerializedObject _lastObject;
	
	public static void DrawArray(this SerializedObject sO, SerializedProperty relativeTo, string title, string arrayName, bool buffer = false)
	{
		sO.DrawArray(relativeTo, title, arrayName, "", buffer);
	}
	public static void DrawArray(this SerializedObject sO, SerializedProperty relativeTo, string title, string arrayName, string baseName, bool buffer = false)
	{
		SerializedProperty array = relativeTo.FindPropertyRelative(arrayName);
		if(array == null || !array.isArray) return;
		drawArray(sO, array, title, arrayName, baseName, buffer);
	}
	
	public static void DrawArray(this SerializedObject sO, string title, string arrayName, bool buffer = false)
	{
		sO.DrawArray(title, arrayName, "", buffer);
	}
	public static void DrawArray(this SerializedObject sO, string title, string arrayName, string baseName, bool buffer = false)
	{
		SerializedProperty array = sO.FindProperty(arrayName);
		if(array == null || !array.isArray) return;
		drawArray(sO, array, title, arrayName, baseName, buffer);
	}

	static void drawArray(SerializedObject sO, SerializedProperty array, string title, string arrayName, string baseName, bool buffer)
	{
		if(_lastObject == null || _lastObject != sO)
		{
			_lastObject = sO;
			_depthTitle = new List<string>();
			_arrayIndex = new List<int>();
			_depth = -1;
		}

		_depthTitle.Add(baseName+"_"+title);
		_fullTitle = "";
		foreach(string s in _depthTitle)
			_fullTitle += s;
		
		_depth++;
		_arrayIndex.Add(0);

		if(!arrayRef.ContainsKey(sO))
		{
			Dictionary<string, ArrayRef> arEntry = new Dictionary<string, ArrayRef>();
			arrayRef.Add(sO, arEntry);
		}
		if(!arrayRef[sO].ContainsKey(arrayName + _fullTitle + _arrayIndex[_depth]))
		{
			arrayRef[sO].Add(arrayName + _fullTitle + _arrayIndex[_depth], new ArrayRef());
		}
		
		ArrayRef aR = arrayRef[sO][arrayName + _fullTitle + _arrayIndex[_depth]];
		aR.maxIndex = array.arraySize - 1;
		
		//bool multiEdit = sO.isEditingMultipleObjects;
		
		GUILayout.BeginVertical();
		if(buffer)
			GUILayout.Space(5);
		if(DrawHeader(title, array.name + "_" + _fullTitle + _arrayIndex))
		{
			float oldLabelWidth = GetLabelWidth();
			SetLabelWidth(20);
			BeginContents();
			{
				for(int i = 0; i < array.arraySize; i++)
				{
					_depthTitle[_depth] = baseName + "_" + title + "_" + i;
					GUILayout.BeginHorizontal();
					GUILayout.Space(5);
					BeginContents();
					{
						GUILayout.BeginHorizontal();
						if(GUILayout.Button("+", GUILayout.Width(24)))
						{
							/*if(multiEdit)
							{
								foreach(UnityEngine.Object o in sO.targetObjects)
									(new SerializedObject(o)).FindProperty(arrayName).InsertArrayElementAtIndex(i);
							} else */
							array.InsertArrayElementAtIndex(i);
						}
						//EditorGUI.BeginDisabledGroup(multiEdit && array.GetArrayElementAtIndex(i).hasMultipleDifferentValues);
						EditorGUILayout.PropertyField(array.GetArrayElementAtIndex(i), new GUIContent(i.ToString()));
						//EditorGUI.EndDisabledGroup();
						GUILayout.Space(3);
						if(GUILayout.Button("-", GUILayout.Width(24)))
						{
							/*if(multiEdit)
							{
								foreach(UnityEngine.Object o in sO.targetObjects)
								{
									SerializedProperty thisArray = (new SerializedObject(o)).FindProperty(arrayName);
									for(int j = i+1; j < thisArray.arraySize; j++)
										thisArray.MoveArrayElement(j, j-1);
									thisArray.arraySize--;
								}
							} else 
							{*/
							for(int j = i+1; j < array.arraySize; j++)
								array.MoveArrayElement(j, j-1);
							array.arraySize--;
							continue;
						}
						GUILayout.EndHorizontal();
					}	EndContents();
					EditorGUI.BeginDisabledGroup(i < 1);
					{	
						if(GUILayout.Button("^", GUILayout.Width(24)))
						{
							/*if(multiEdit)
							{
								foreach(UnityEngine.Object o in sO.targetObjects)
									(new SerializedObject(o)).FindProperty(arrayName).MoveArrayElement(i, i - 1);
							} else*/
							array.MoveArrayElement(i, i - 1);
						}
					} EditorGUI.EndDisabledGroup();
					EditorGUI.BeginDisabledGroup(i == array.arraySize - 1);
					{	
						if(GUILayout.Button("v", GUILayout.Width(24)))
						{
							/*if(multiEdit)
							{
								foreach(UnityEngine.Object o in sO.targetObjects)
									(new SerializedObject(o)).FindProperty(arrayName).MoveArrayElement(i, i + 1);
							} else*/
							array.MoveArrayElement(i, i + 1);
						}
					} EditorGUI.EndDisabledGroup();
					
					EditorGUI.BeginDisabledGroup(array.arraySize < 2);
					{
						bool selected = aR.swap1 == i || aR.swap2 == i;
						bool toggled = GUILayout.Toggle(selected, "");
						
						if(selected != toggled)
						{
							if(toggled)
							{
								if(aR.swap1 == -1)
									aR.swap1 = i;
								else if(aR.swap2 == -1)
									aR.swap2 = i;
								else
									aR.swap1 = i;
							} else
							{
								if(aR.swap1 == i)
									aR.swap1 = aR.swap2;
								aR.swap2 = -1;
							}
						}
					} EditorGUI.EndDisabledGroup();
					
					GUILayout.Space(-7);
					GUILayout.EndHorizontal();
					_arrayIndex[_depth]++;
				}
				
				GUILayout.BeginHorizontal();
				GUILayout.Space(9);
				if(GUILayout.Button("+", GUILayout.Width(24)))
				{
					/*if(multiEdit)
					{
						foreach(UnityEngine.Object o in sO.targetObjects)
						{
							SerializedProperty sP = (new SerializedObject(o)).FindProperty(arrayName);
							sP.InsertArrayElementAtIndex(sP.arraySize);
						}
					}
					else*/
					array.InsertArrayElementAtIndex(array.arraySize);
				}
				GUILayout.Space(2);
				int numSelected = ((aR.swap1 != -1) ? 1 : 0) + ((aR.swap2 != -1) ? 1 : 0);
				if(numSelected == 1)
				{
					if(GUILayout.Button("Send To"))
					{
						int index = 1 + aR.swap1 + aR.swap2;
						if(index > aR.index)
						{
							for(; index > aR.index; index--)
								array.MoveArrayElement(index, index-1);
						} else if(index < aR.index)
						{
							for(; index < aR.index; index++)
								array.MoveArrayElement(index, index+1);
						}
						
						if(aR.swap1 != -1)
							aR.swap1 = aR.index;
						else
							aR.swap2 = aR.index;
					}
					aR.index = EditorGUILayout.IntField(aR.index);
					if(GUILayout.Button("Deselect", GUILayout.Width(70)))
					{
						aR.swap1 = -1;
						aR.swap2 = -1;
					}
				} else if(numSelected == 2)
				{
					if(GUILayout.Button("Swap"))
					{
						if(aR.swap1 < aR.swap2)
						{
							array.MoveArrayElement(aR.swap1, aR.swap2);
							array.MoveArrayElement(aR.swap2 - 1, aR.swap1);
						} else
						{
							array.MoveArrayElement(aR.swap1, aR.swap2);
							array.MoveArrayElement(aR.swap2 + 1, aR.swap1);
						}
					}
					if(GUILayout.Button("Deselect", GUILayout.Width(70)))
					{
						aR.swap1 = -1;
						aR.swap2 = -1;
					}
				} else if(aR.lastSwap1 != -1 || aR.lastSwap2 != -1)
				{
					GUILayout.FlexibleSpace();
					if(GUILayout.Button("Clear", GUILayout.Width(50)))
					{
						aR.ResetLastSwaps();
					}
					if(GUILayout.Button("Reselect", GUILayout.Width(70)))
					{
						aR.swap1 = aR.lastSwap1;
						aR.swap2 = aR.lastSwap2;
					}
				}
				GUILayout.EndHorizontal();
			} EndContents();
			SetLabelWidth(oldLabelWidth);
		}
		_depthTitle.RemoveAt(_depth);
		arrayRef[sO][arrayName + _fullTitle + _arrayIndex[_depth]] = aR;
		_arrayIndex.RemoveAt(_depth);
		_depth--;

		if(buffer)
			GUILayout.Space(5);
		GUILayout.EndVertical();
	}

	public static void CopyArray<T>(this SerializedObject sO, string source, string destination)
	{
		SerializedProperty _source = sO.FindProperty(source);
		SerializedProperty _destination = sO.FindProperty(destination);

		if(_source != null && _destination != null && _source.isArray && _destination.isArray)
		{
			sO.SetArray<T>(_source, _destination);
		}
	}
	#endregion

	#region Get Array
	public static T[] GetArray<T>(this SerializedObject sO, string array)
	{
		SerializedProperty sp = sO.FindProperty(array);
		
		return sO.GetArray<T>(sp);
	}
	public static T[] GetArray<T>(this SerializedObject sO, SerializedProperty array)
	{
		if(array == null || !array.isArray) return new T[0];

		T[] tArray = new T[array.arraySize];
		Type valueType = typeof(T);
		
		// First, do special Type checks
		if (valueType.IsEnum)
			for(int i = 0; i < array.arraySize; i++)
				tArray[i] = (T)Enum.ToObject(valueType, array.GetArrayElementAtIndex(i).enumValueIndex);
		
		// Next, check for literal UnityEngine struct-types
		if (typeof(Color).IsAssignableFrom(valueType))
			for(int i = 0; i < array.arraySize; i++)
				tArray[i] = (T)(object)array.GetArrayElementAtIndex(i).colorValue;
		else if (typeof(LayerMask).IsAssignableFrom(valueType))
			for(int i = 0; i < array.arraySize; i++)
				tArray[i] = (T)(object)array.GetArrayElementAtIndex(i).intValue;
		else if (typeof(Vector2).IsAssignableFrom(valueType))
			for(int i = 0; i < array.arraySize; i++)
				tArray[i] = (T)(object)array.GetArrayElementAtIndex(i).vector2Value;
		else if (typeof(Vector3).IsAssignableFrom(valueType))
			for(int i = 0; i < array.arraySize; i++)
				tArray[i] = (T)(object)array.GetArrayElementAtIndex(i).vector3Value;
		else if (typeof(Rect).IsAssignableFrom(valueType))
			for(int i = 0; i < array.arraySize; i++)
				tArray[i] = (T)(object)array.GetArrayElementAtIndex(i).rectValue;
		else if (typeof(AnimationCurve).IsAssignableFrom(valueType))
			for(int i = 0; i < array.arraySize; i++)
				tArray[i] = (T)(object)array.GetArrayElementAtIndex(i).animationCurveValue;
		else if (typeof(Bounds).IsAssignableFrom(valueType))
			for(int i = 0; i < array.arraySize; i++)
				tArray[i] = (T)(object)array.GetArrayElementAtIndex(i).boundsValue;
		else if (typeof(Gradient).IsAssignableFrom(valueType))
			for(int i = 0; i < array.arraySize; i++)
				tArray[i] = (T)(object)SafeGradientValue(array.GetArrayElementAtIndex(i));
		else if (typeof(Quaternion).IsAssignableFrom(valueType))
			for(int i = 0; i < array.arraySize; i++)
				tArray[i] = (T)(object)array.GetArrayElementAtIndex(i).quaternionValue;
		
		// Next, check if derived from UnityEngine.Object base class
		if (typeof(UnityEngine.Object).IsAssignableFrom(valueType))
			for(int i = 0; i < array.arraySize; i++)
				tArray[i] = (T)(object)array.GetArrayElementAtIndex(i).objectReferenceValue;
		
		// Finally, check for native type-families
		if (typeof(int).IsAssignableFrom(valueType))
			for(int i = 0; i < array.arraySize; i++)
				tArray[i] = (T)(object)array.GetArrayElementAtIndex(i).intValue;
		else if (typeof(bool).IsAssignableFrom(valueType))
			for(int i = 0; i < array.arraySize; i++)
				tArray[i] = (T)(object)array.GetArrayElementAtIndex(i).boolValue;
		else if (typeof(float).IsAssignableFrom(valueType))
			for(int i = 0; i < array.arraySize; i++)
				tArray[i] = (T)(object)array.GetArrayElementAtIndex(i).floatValue;
		else if (typeof(string).IsAssignableFrom(valueType))
			for(int i = 0; i < array.arraySize; i++)
				tArray[i] = (T)(object)array.GetArrayElementAtIndex(i).stringValue;
		else if (typeof(char).IsAssignableFrom(valueType))
			for(int i = 0; i < array.arraySize; i++)
				tArray[i] = (T)(object)array.GetArrayElementAtIndex(i).intValue;

		return tArray;
	}
	public static void SetArray<T>(this SerializedObject sO, SerializedProperty source, SerializedProperty destination)
	{
		if(source == null || !source.isArray || destination == null || !destination.isArray) return;

		destination.arraySize = source.arraySize;
		Type valueType = typeof(T);
		
		// First, do special Type checks
		if (valueType.IsEnum)
			for(int i = 0; i < source.arraySize; i++)
				destination.GetArrayElementAtIndex(i).enumValueIndex = source.GetArrayElementAtIndex(i).enumValueIndex;
		
		// Next, check for literal UnityEngine struct-types
		if (typeof(Color).IsAssignableFrom(valueType))
			for(int i = 0; i < source.arraySize; i++)
				destination.GetArrayElementAtIndex(i).colorValue = source.GetArrayElementAtIndex(i).colorValue;
		else if (typeof(LayerMask).IsAssignableFrom(valueType))
			for(int i = 0; i < source.arraySize; i++)
				destination.GetArrayElementAtIndex(i).intValue = source.GetArrayElementAtIndex(i).intValue;
		else if (typeof(Vector2).IsAssignableFrom(valueType))
			for(int i = 0; i < source.arraySize; i++)
				destination.GetArrayElementAtIndex(i).vector2Value = source.GetArrayElementAtIndex(i).vector2Value;
		else if (typeof(Vector3).IsAssignableFrom(valueType))
			for(int i = 0; i < source.arraySize; i++)
				destination.GetArrayElementAtIndex(i).vector3Value = source.GetArrayElementAtIndex(i).vector3Value;
		else if (typeof(Rect).IsAssignableFrom(valueType))
			for(int i = 0; i < source.arraySize; i++)
				destination.GetArrayElementAtIndex(i).rectValue = source.GetArrayElementAtIndex(i).rectValue;
		else if (typeof(AnimationCurve).IsAssignableFrom(valueType))
			for(int i = 0; i < source.arraySize; i++)
				destination.GetArrayElementAtIndex(i).animationCurveValue = source.GetArrayElementAtIndex(i).animationCurveValue;
		else if (typeof(Bounds).IsAssignableFrom(valueType))
			for(int i = 0; i < source.arraySize; i++)
				destination.GetArrayElementAtIndex(i).boundsValue = source.GetArrayElementAtIndex(i).boundsValue;
		else if (typeof(Quaternion).IsAssignableFrom(valueType))
			for(int i = 0; i < source.arraySize; i++)
				destination.GetArrayElementAtIndex(i).quaternionValue = source.GetArrayElementAtIndex(i).quaternionValue;
		
		// Next, check if derived from UnityEngine.Object base class
		if (typeof(UnityEngine.Object).IsAssignableFrom(valueType))
			for(int i = 0; i < source.arraySize; i++)
				destination.GetArrayElementAtIndex(i).objectReferenceValue = source.GetArrayElementAtIndex(i).objectReferenceValue;
		
		// Finally, check for native type-families
		if (typeof(int).IsAssignableFrom(valueType))
			for(int i = 0; i < source.arraySize; i++)
				destination.GetArrayElementAtIndex(i).intValue = source.GetArrayElementAtIndex(i).intValue;
		else if (typeof(bool).IsAssignableFrom(valueType))
			for(int i = 0; i < source.arraySize; i++)
				destination.GetArrayElementAtIndex(i).boolValue = source.GetArrayElementAtIndex(i).boolValue;
		else if (typeof(float).IsAssignableFrom(valueType))
			for(int i = 0; i < source.arraySize; i++)
				destination.GetArrayElementAtIndex(i).floatValue = source.GetArrayElementAtIndex(i).floatValue;
		else if (typeof(string).IsAssignableFrom(valueType))
			for(int i = 0; i < source.arraySize; i++)
				destination.GetArrayElementAtIndex(i).stringValue = source.GetArrayElementAtIndex(i).stringValue;
		else if (typeof(char).IsAssignableFrom(valueType))
			for(int i = 0; i < source.arraySize; i++)
				destination.GetArrayElementAtIndex(i).intValue = source.GetArrayElementAtIndex(i).intValue;
	}
	
	/// Access to SerializedProperty's internal gradientValue property getter, in a manner that'll only soft break (returning null) if the property changes or disappears in future Unity revs.
	static Gradient SafeGradientValue(SerializedProperty sp)
	{
		BindingFlags instanceAnyPrivacyBindingFlags = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance;
		PropertyInfo propertyInfo = typeof(SerializedProperty).GetProperty(
			"gradientValue",
			instanceAnyPrivacyBindingFlags,
			null,
			typeof(Gradient),
			new Type[0],
			null
			);
		if (propertyInfo == null)
			return null;
		
		Gradient gradientValue = propertyInfo.GetValue(sp, null) as Gradient;
		return gradientValue;
	}
	#endregion

	#region Inspector Tools
	public static bool minimalisticLook
	{
		get { return EditorPrefs.GetBool("NGUI Minimalistic", false); }
		set { EditorPrefs.SetBool("NGUI Minimalistic", value); }
	}

	public static void SetLabelWidth(float width)
	{
		EditorGUIUtility.labelWidth = width;
	}

	public static float GetLabelWidth()
	{
		return EditorGUIUtility.labelWidth;
	}
	#endregion

	#region Inspector Lock
	public class InspectorLockToggle
	{
		private static EditorWindow _mouseOverWindow;
		
		[MenuItem("Stuff/Select Inspector under mouse cursor (use hotkey) #&q")]
		static void SelectLockableInspector()
		{
			if (EditorWindow.mouseOverWindow.GetType().Name == "InspectorWindow")
			{
				_mouseOverWindow = EditorWindow.mouseOverWindow;
				Type type = Assembly.GetAssembly(typeof(Editor)).GetType("UnityEditor.InspectorWindow");
				UnityEngine.Object[] findObjectsOfTypeAll = Resources.FindObjectsOfTypeAll(type);
				int indexOf = findObjectsOfTypeAll.ToList().IndexOf(_mouseOverWindow);
				EditorPrefs.SetInt("LockableInspectorIndex", indexOf);
			}
		}
		
		[MenuItem("Stuff/Toggle Lock &q")]
		static void ToggleInspectorLock()
		{
			if (_mouseOverWindow == null)
			{
				if (!EditorPrefs.HasKey("LockableInspectorIndex"))
					EditorPrefs.SetInt("LockableInspectorIndex", 0);
				int i = EditorPrefs.GetInt("LockableInspectorIndex");
				
				Type type = Assembly.GetAssembly(typeof(Editor)).GetType("UnityEditor.InspectorWindow");
				UnityEngine.Object[] findObjectsOfTypeAll = Resources.FindObjectsOfTypeAll(type);
				_mouseOverWindow = (EditorWindow)findObjectsOfTypeAll[i];
			}
			
			if (_mouseOverWindow != null && _mouseOverWindow.GetType().Name == "InspectorWindow")
			{
				Type type = Assembly.GetAssembly(typeof(Editor)).GetType("UnityEditor.InspectorWindow");
				PropertyInfo propertyInfo = type.GetProperty("isLocked");
				bool value = (bool)propertyInfo.GetValue(_mouseOverWindow, null);
				propertyInfo.SetValue(_mouseOverWindow, !value, null);
				_mouseOverWindow.Repaint();
			}
		}
		
		[MenuItem("Stuff/Clear Console #&c")]
		static void ClearConsole()
		{
			Type type = Assembly.GetAssembly(typeof(Editor)).GetType("UnityEditorInternal.LogEntries");
			type.GetMethod("Clear").Invoke(null,null);
		}
	}
	#endregion

    #region Parent

    #region Create
    [MenuItem("GameObject/Create Parent/Origin")]
    static Transform CreateOriginParent()
    {
        Transform[] transforms = Selection.transforms;

        GameObject parent = new GameObject("New Parent");
        Undo.RegisterCreatedObjectUndo(parent, "Created parent");

        foreach (Transform t in transforms)
        {
            Undo.SetTransformParent(t, parent.transform, "Parented " + t.name + " to " + parent.name);
        }
        Selection.activeGameObject = parent;

        return parent.transform;
    }

    [MenuItem("GameObject/Create Parent/Origin", true, 201)]
    static bool ValidateCreateOriginParent()
    {
        return Selection.transforms.Length != 0;
    }

    ////////////////////////////////////////////////

    [MenuItem("GameObject/Create Parent/Centered")]
    static Transform CreateCenteredParent()
    {
        Transform[] transforms = Selection.transforms;

        // Get center of transforms
        Vector3 position = Vector3.zero;
        Transform grandParent = transforms[0].parent;
        bool siblings = grandParent != null;
        foreach (Transform t in transforms)
        {
            position += t.position;
            if (siblings)
                siblings = t.parent == grandParent;
        }
        position = position / transforms.Length;

        GameObject parent = new GameObject("New Parent");
        parent.transform.position = position;
        parent.transform.localScale = Vector3.one;
        Undo.RegisterCreatedObjectUndo(parent, "Created parent");
        if(siblings)
            Undo.SetTransformParent(parent.transform, grandParent, "Parented " + parent.name + " to " + grandParent.name);

        foreach (Transform t in transforms)
        {
            Undo.SetTransformParent(t, parent.transform, "Parented " + t.name + " to " + parent.name);
        }
        Selection.activeGameObject = parent;

        return parent.transform;
    }

    [MenuItem("GameObject/Create Parent/Centered", true, 202)]
    static bool ValidateCreateCenteredParent()
    {
        return Selection.transforms.Length != 0;
    }

    ////////////////////////////////////////////////

    [MenuItem("GameObject/Create Parent/Centered with Rotation")]
    static Transform CreateCenteredParentWithRotation()
    {
        Transform[] transforms = Selection.transforms;

        // Get rotation of transforms
        Vector3 rotation = Vector3.zero;
        foreach (Transform t in transforms)
            rotation += t.eulerAngles;
        rotation = rotation / transforms.Length;

        Transform parent = CreateCenteredParent();

        foreach (Transform t in transforms)
            Undo.SetTransformParent(t, parent.parent, "Parented " + t + " to " + parent.parent);

        Undo.RecordObject(parent, "Setting " + parent.name + " rotation");
        parent.rotation = Quaternion.Euler(rotation);

        foreach (Transform t in transforms)
            Undo.SetTransformParent(t, parent, "Parented " + t + " to " + parent);

        Selection.activeGameObject = parent.gameObject;

        return parent.transform;
    }

    [MenuItem("GameObject/Create Parent/Centered with Rotation", true, 203)]
    static bool ValidateCreateCenteredParentWithRotation()
    {
        return Selection.transforms.Length != 0;
    }
    #endregion


    #region Move
    [MenuItem("GameObject/Move Parent/To Center")]
    static Transform MoveParentToCenter()
    {
        Transform[] transforms = Selection.transforms;

        // Get center of transforms
        Vector3 position = Vector3.zero;
        Vector3 rotation = Vector3.zero;
        Transform parent = transforms[0].parent;

        foreach (Transform t in transforms)
        {
            position += t.position;
            rotation += t.eulerAngles;
        }
        position = position / transforms.Length;
        rotation = rotation / transforms.Length;

        Transform[] siblings = parent.GetChildren();
        foreach (Transform t in siblings)
            Undo.SetTransformParent(t, parent.parent, "Parented " + t.name + " to " + parent.parent.name);

        Undo.RecordObject(parent, "Centering " + parent.name);
        parent.position = position;
        parent.rotation = Quaternion.Euler(rotation);

        foreach (Transform t in siblings)
            Undo.SetTransformParent(t, parent, "Parented " + t.name + " to " + parent.name);

        Selection.activeGameObject = parent.gameObject;

        return parent;
    }


    [MenuItem("GameObject/Move Parent/To Center", true, 211)]
    static bool ValidateMoveParentToCenter()
    {
        Transform[] transforms = Selection.transforms;
        bool siblings = Selection.transforms.Length != 0;

        if (siblings)
        {
            Transform grandParent = transforms[0].parent;
            siblings = grandParent != null;
            foreach (Transform t in transforms)
            {
                if (siblings)
                    siblings = t.parent == grandParent;
                else break;
            }
        }

        return siblings;
	}


	[MenuItem("GameObject/Move Parent/To Origin")]
	static Transform MoveParentToOrigin()
	{
		Transform[] transforms = Selection.transforms;

		Transform parent = transforms[0].parent;
		
		Transform[] siblings = parent.GetChildren();
		foreach (Transform t in siblings)
			Undo.SetTransformParent(t, parent.parent, "Parented " + t.name + " to " + parent.parent.name);
		
		Undo.RecordObject(parent, "Origining " + parent.name);
		parent.position = Vector3.zero;
		parent.rotation = Quaternion.identity;
		
		foreach (Transform t in siblings)
			Undo.SetTransformParent(t, parent, "Parented " + t.name + " to " + parent.name);
		
		Selection.activeGameObject = parent.gameObject;
		
		return parent;
	}
	
	
	[MenuItem("GameObject/Move Parent/To Origin", true, 212)]
	static bool ValidateMoveParentToOrigin()
	{
		Transform[] transforms = Selection.transforms;
		bool siblings = Selection.transforms.Length != 0;
		
		if (siblings)
		{
			Transform grandParent = transforms[0].parent;
			siblings = grandParent != null;
			foreach (Transform t in transforms)
			{
				if (siblings)
					siblings = t.parent == grandParent;
				else break;
			}
		}
		
		return siblings;
	}
    #endregion


    #region Move To
    [MenuItem("GameObject/Move To/Center Of Children")]
    static Transform[] MoveToCenterOfChildren()
    {
        Transform[] transforms = Selection.transforms;

        foreach (Transform parent in transforms)
        {
            if (parent.childCount != 0)
            {
                Transform[] children = parent.GetChildren();
                // Get center of transforms
                Vector3 position = Vector3.zero;

                foreach (Transform t in children)
                    position += t.position;

                position = position / children.Length;

                foreach (Transform t in children)
                    Undo.SetTransformParent(t, parent.parent, "Parented " + t.name + " to " + parent.parent.name);

                Undo.RecordObject(parent, "Centering " + parent.name);
                parent.position = position;

                foreach (Transform t in children)
                    Undo.SetTransformParent(t, parent, "Parented " + t.name + " to " + parent.name);
            }
        }

        return transforms;
    }


    [MenuItem("GameObject/Move To/Center Of Children", true, 221)]
    static bool ValidateMoveToCenterOfChildren()
    {
        return Selection.transforms.Length != 0;
    }

    ////////////////////////////////////////////////

    [MenuItem("GameObject/Move To/Center of Children with Rotation")]
    static Transform[] MoveToCenterOfChildrenWithRotation()
    {
        Transform[] transforms = Selection.transforms;

        foreach (Transform parent in transforms)
        {
            if (parent.childCount != 0)
            {
                Transform[] children = parent.GetChildren();
                // Get center of transforms
                Vector3 position = Vector3.zero;
                Vector3 rotation = Vector3.zero;

                foreach (Transform t in children)
                {
                    position += t.position;
                    rotation += t.eulerAngles;
                }
                position = position / children.Length;
                rotation = rotation / children.Length;

                foreach (Transform t in children)
                    Undo.SetTransformParent(t, parent.parent, "Parented " + t.name + " to " + parent.parent.name);

                Undo.RecordObject(parent, "Centering " + parent.name);
                parent.position = position;
                parent.rotation = Quaternion.Euler(rotation);

                foreach (Transform t in children)
                    Undo.SetTransformParent(t, parent, "Parented " + t.name + " to " + parent.name);
            }
        }

        return transforms;
    }


    [MenuItem("GameObject/Move To/Center of Children with Rotation", true, 222)]
    static bool ValidateMoveToCenterOfChildrenWithRotation()
    {
        return Selection.transforms.Length != 0;
    }
    #endregion
    #endregion

    #region Set Transform
    [MenuItem("GameObject/Set Transform/Scale Of 1")]
    static Transform[] SetTransformToScaleOne()
    {
        Transform[] transforms = Selection.transforms;

        foreach (Transform parent in transforms)
        {
            if (parent.childCount != 0)
            {
                Transform[] children = parent.GetChildren();
                foreach (Transform t in children)
                    Undo.SetTransformParent(t, null, "Parented " + t + " to null");

                Undo.RecordObject(parent, "Setting scale of " + parent.name + " to 1");
                parent.localScale = Vector3.one;

                foreach (Transform t in children)
                    Undo.SetTransformParent(t, parent, "Parented " + t + " to " + parent);
            }
            else
            {
                Undo.RecordObject(parent, "Setting scale of " + parent.name + " to 1");
                parent.localScale = Vector3.one;
            }
        }

        return transforms;
    }


    [MenuItem("GameObject/Set Transform/Scale Of 1", true, 231)]
    static bool ValidateSetTransformToScaleOne()
    {
        return Selection.transforms.Length != 0;
    }

    ////////////////////////////////////////////////

    [MenuItem("GameObject/Set Transform/Rotation of 0")]
    static Transform[] SetTransformToRotationZero()
    {
        Transform[] transforms = Selection.transforms;

        foreach (Transform parent in transforms)
        {
            if (parent.childCount != 0)
            {
                Transform[] children = parent.GetChildren();
                foreach (Transform t in children)
                    Undo.SetTransformParent(t, null, "Parented " + t + " to null");

                Undo.RecordObject(parent, "Setting rotation of " + parent.name + " to 1");
                parent.rotation = Quaternion.identity;

                foreach (Transform t in children)
                    Undo.SetTransformParent(t, parent, "Parented " + t + " to " + parent);
            }
            else
            {
                Undo.RecordObject(parent, "Setting scale of " + parent.name + " to 1");
                parent.localScale = Vector3.one;
            }
        }

        return transforms;
    }


    [MenuItem("GameObject/Set Transform/Rotation of 0", true, 231)]
    static bool ValidateSetTransformToRotationZero()
    {
        return Selection.transforms.Length != 0;
    }

    ////////////////////////////////////////////////

    [MenuItem("GameObject/Set Transform/Center on Children, Scale 1 %#c")]
    static Transform[] CenterOnChildrenAndScaleToOne()
    {
        MoveToCenterOfChildren();
        SetTransformToScaleOne();

        return Selection.transforms;
    }


	[MenuItem("GameObject/Set Transform/Center on Children, Scale 1 %#c", true, 232)]
    static bool ValidateCenterOnChildrenAndScaleToOne()
    {
        return Selection.transforms.Length != 0;
    }

    ////////////////////////////////////////////////

    [MenuItem("GameObject/Set Transform/Center on Children, Scale 1, Rotation 0 %#x")]
    static Transform[] CenterOnChildrenScaleToOneAndRotationToZero()
    {
        MoveToCenterOfChildren();
        SetTransformToScaleOne();
        SetTransformToRotationZero();

        return Selection.transforms;
    }


	[MenuItem("GameObject/Set Transform/Center on Children, Scale 1, Rotation 0 %#x", true, 232)]
    static bool ValidateCenterOnChildrenScaleToOneAndRotationToZero()
    {
        return Selection.transforms.Length != 0;
    }
    #endregion

	#region BitMask
	public static int DrawBitMaskField(Rect aPosition, int aMask, System.Type aType, GUIContent aLabel)
	{
		var itemNames = System.Enum.GetNames(aType);
		var itemValues = System.Enum.GetValues(aType) as int[];

		int val = aMask;
		int maskVal = 0;

		for(int i = 0; i < itemValues.Length; i++)
		{
			if(itemValues[i] != 0)
			{
				if((val & itemValues[i]) == itemValues[i])
					maskVal |= 1 << i;
			} else if(val == 0)
				maskVal |= 1 << i;
		}
		int newMaskVal = EditorGUI.MaskField(aPosition, aLabel, maskVal, itemNames);
		int changes = maskVal ^ newMaskVal;

		for(int i = 0; i < itemValues.Length; i++)
		{
			if((changes & (1 << i)) != 0)
			{
				if((newMaskVal & (1 << i)) != 0)
				{
					if(itemValues[i] == 0)
					{
						val = 0;
						break;
					} else
						val |= itemValues[i];
				} else
					val &= ~itemValues[i];
			}
		}

		return val;
	}
	#endregion
}